## Coding Now ！

先从 《挑程》开始吧！

[TOC]



### 第一章

#### 1.6.1 三角形

书上直接使用了三重循环，遍历所有的边的组合情况，两次 max 函数得到最长边，根据 “两边之和大于第三边” 条件找到结果。也可以先进行排序，这样按照从大到小的顺序每次选择三条边进行检测就可以了，并且符合要求的三条边必定是相邻的，这种写法会简单一些。

#### 1.6.2 Ants

思路很巧的问题，题目让求解最短时间和最长时间，最短时间好求，最好的情况是所有的蚂蚁都朝离边缘最短的方向移动，这样也会避免相遇的情况，所以这时候，对于每只蚂蚁最短时间就是

```
min(左边距离， 右边距离)
```

然后对于所有蚂蚁而言，总体最短时间是每只蚂蚁最短时间的最大值：

```
min_length = max(min_1, min_2 ...)
```

对于最长时间，首先思考，如果两只蚂蚁相遇会发生什么，题目中说两只蚂蚁会往相反的方向走，但是这个碰面转向的时候，我们用蚂蚁A和蚂蚁B交换，这样最后的时间是不会有变化的，但是整体而言，这样就与蚂蚁相遇之后继续按照自己的方向走没区别了，所以**对于蚂蚁相遇的发杂情况，依然可以每只蚂蚁单独考虑**.,所以所有蚂蚁离边缘最长的距离就是整体最长的距离了:

```
max_length = max(max_1, max_2, max_3 ...)
```

C++中直接使用预定义的int最大最小值：

```
cout<<INT_MAX<<endl;
cout<<INT_MIN<<endl;
```

#### 1.6.3 Draw

抽签问题，问题在于四种数字如何全部罗列的话，时间复杂度过高，所以需要考虑优化的问题，

- 对最内层的优化：考虑到前三个数字确定的话，实际上第四个数字也就确定了，只需要检测一下第四个数字是否存在于数组之中就可以了。对于这个查找的过程可以使用二分查找的方式进行优化。这样三层循环加上二分查找的时间，总体的时间复杂度是 O(n**3logn)
- 如果将内层的两个数字都考虑进去，可以事先打一个表，计算任意两个数字的和，那么只需要遍历两遍数组，然后判断时候剩下的数字和在打的表里就可以了。这个查找的过程仍然可以使用二分查找，所以整体的时间复杂度是O(n**2logn)

### 第二章

### 2.1.4 DFS

第一个问题：Segmental Sum，求部分和的问题，对于这个数组中的所有数字而言，每个数字都只有两种可能，选择 或者 不选择 ，所以我们按照数组的索引进行DFS，得到所有的可能情况。

第二个问题：Lake Counting，计算水洼的数量，非常经典的DFS题目，从地图的左上角开始搜索，首先找到水洼的位置，然后从周围的八个位置进行搜索，注意每次开始搜索的时候要注意将地图改成没有积水的字符，这样每次搜索都会将周围相连的水洼字符改掉，这样最后在外层循环中dfs的数量就是水洼的数目。

### 2.1.5 BFS

按照临近状态进行搜索，两种搜索方式，DFS适合使用栈的方式计算，BFS则是队列方式，不断将新的状态加入到队列中，然后从队列头部取出状态及逆行遍历，直到队列为空。这种方式很适合寻找最短路径。

### 2.2.1 硬币问题

经典贪心题目，注意计算数量的时候取理论计算的数量和实际数量的最小值：

```
int temp = min(a/val[t], cou[t]);
```

### 2.2.2 区间调度问题

对于所有的时间段来说，有几种不同的选择方式，按照开始时间或者结束时间等等。这里是按照结束时间进行选择，注意 `pair`这种结构体的使用以及如何只当排序的方式。

### 2.2.3 字典序最小问题

从一个字符串中定义两种操作：从头取出一个字符和从尾部取出一个字符，然后按照取出顺序排列这个字符串，求解字典序最小字符串。很直接的想法就是每次比较一下，然后取字典序小的字符，但是要注意的一个问题是如果出现了多个相同字符的情况，例如`abdceba`，这种情况下，应该在比较完开头和结尾字符后继续向内部查看，一直比较到`d`和`e`才能确定应该取头上的`a`，所以添加一个循环判断一下这种情况即可。